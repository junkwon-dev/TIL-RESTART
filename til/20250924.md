## 효과적인 유닛 테스트를 위한 필수 개념, Mock, Stub, Spy의 차이점

### 서론

소프트웨어 개발 과정에서 **테스트**는 필수적인 부분입니다. 특히, **유닛 테스트**는 개별 코드 단위가 의도한 대로 동작하는지 확인하여 안정적인 애플리케이션을 만드는 데 중요한 역할을 합니다. 하지만 테스트를 하다 보면 외부 시스템이나 복잡한 의존성 때문에 테스트 환경을 구축하기 어려운 경우가 발생합니다. 이럴 때 **테스트 더블(Test Double)**이라는 기술을 활용하여 문제를 해결할 수 있습니다.

테스트 더블에는 여러 종류가 있으며, 그중에서도 **Mock, Stub, Spy**는 가장 널리 사용되는 개념입니다. 이 세 가지는 모두 실제 객체 대신 가짜 객체를 만들어 테스트를 진행하지만, 각각의 목적과 역할이 명확하게 다릅니다. 이 글에서는 Mock, Stub, Spy의 개념과 차이점을 명확히 정리하고, 언제 어떤 것을 사용해야 하는지 심도 있게 다룹니다.

-----

### 본론: Mock, Stub, Spy 상세 분석

Mock, Stub, Spy는 모두 테스트 대상 객체의 \*\*의존성(dependency)\*\*을 격리하여 테스트의 신뢰성과 효율성을 높이는 도구입니다. 이들은 서로 다른 목적과 사용 시나리오를 가집니다.

#### 1\. Stub (스터브)

**Stub**은 테스트 대상이 의존하는 객체로부터 **특정 값을 반환받기 위해 사용되는 객체**입니다. Stub의 주된 목적은 테스트 환경을 안정적으로 만들기 위해 예측 가능한 데이터를 제공하는 것입니다. 즉, Stub은 특정 메서드가 호출되었을 때 미리 정의된 **하드코딩된 값**을 반환하도록 설정됩니다.

**Stub의 특징:**

* **상태 기반 테스트:** Stub은 테스트 대상의 내부 상태 변화를 확인하는 데 주로 사용됩니다.
* **단순한 데이터 제공:** 복잡한 로직을 수행하지 않고, 미리 정해진 값만 반환합니다.
* **사용 예시:** 로그인 서비스 테스트 시, `UserService`를 Stub으로 만들어 `isUserValid(userId)` 메서드가 항상 `true`를 반환하게 설정할 수 있습니다.

**Stub 예제 코드 (JavaScript - Jest)**

```javascript
// Stub 객체 생성
const userStub = {
  isUserValid: jest.fn(() => true), // 항상 true를 반환하는 Stub 메서드
};

// 테스트 대상 객체
const authService = new AuthService(userStub);

test('유효한 사용자는 로그인에 성공해야 합니다.', () => {
  const result = authService.login('validUser');
  expect(result).toBe(true);
});
```

-----

#### 2\. Mock (목)

**Mock**은 테스트 대상 객체의 **행동을 검증하기 위해 사용되는 객체**입니다. Stub이 특정 값을 반환하는 데 초점을 맞춘다면, Mock은 특정 메서드가 **예상대로 호출되었는지, 어떤 인자와 함께 호출되었는지**를 검증하는 데 중점을 둡니다. Mock은 테스트 대상과 다른 객체 간의 **상호작용**을 확인하는 데 필수적입니다.

**Mock의 특징:**

* **행동 기반 테스트:** Mock은 테스트 대상이 의존성 객체와 올바르게 상호작용했는지를 검증합니다.
* **기대(Expectation) 설정:** 테스트 실행 전에 어떤 메서드가 몇 번 호출될지, 어떤 인자와 함께 호출될지 등을 미리 정의합니다.
* **사용 예시:** 결제 서비스 테스트 시, `PaymentService`가 `AnalyticsService`의 `trackEvent` 메서드를 `('purchase', amount)`와 같은 올바른 인자와 함께 호출하는지 검증하는 데 사용됩니다.

**Mock 예제 코드 (JavaScript - Jest)**

```javascript
// Mock 객체 생성
const analyticsMock = {
  trackEvent: jest.fn(), // 호출 여부를 추적할 Mock 함수
};

// 테스트 대상 객체
const paymentService = new PaymentService(analyticsMock);

test('결제 완료 시 분석 이벤트가 추적되어야 합니다.', () => {
  paymentService.completePayment(1000);
  expect(analyticsMock.trackEvent).toHaveBeenCalledWith('purchase', 1000);
});
```

-----

#### 3\. Spy (스파이)

**Spy**는 **실제 객체의 일부 로직을 그대로 사용하면서, 특정 메서드 호출만 관찰하거나 대체**할 때 사용되는 객체입니다. Stub이나 Mock이 완전한 가짜 객체를 만드는 반면, Spy는 실제 객체 위에 '스파이'를 설치하는 개념입니다. 이를 통해 실제 객체의 동작을 유지하면서도 필요한 부분만 제어하거나 기록할 수 있습니다.

**Spy의 특징:**

* **부분적인 테스트 더블:** 실제 객체의 기능을 유지하면서 특정 메서드만 감시하거나 대체합니다.
* **실행 관찰:** 메서드 호출 횟수, 인자 등을 기록합니다.
* **사용 예시:** 복잡한 서비스 객체의 `processData` 메서드를 테스트할 때, 그 내부의 `validate` 메서드 호출은 감시하고 싶지만, `save` 메서드는 실제 DB에 저장되도록 하고 싶을 때 Spy를 사용합니다.

**Spy 예제 코드 (JavaScript - Jest)**

```javascript
// 실제 객체
const complexService = new ComplexService();

// 특정 메서드에 스파이 설치
const validateSpy = jest.spyOn(complexService, 'validate');

test('데이터 처리 시 유효성 검사 메서드가 호출되어야 합니다.', () => {
  complexService.processData('test data');
  expect(validateSpy).toHaveBeenCalled();
});
```

#### Mock, Stub, Spy 한눈에 비교하기

세 가지 개념의 핵심 차이점을 아래 표를 통해 명확히 이해할 수 있습니다.

| 구분 | Stub (스터브) | Mock (목) | Spy (스파이) |
|:---:|:---:|:---:|:---:|
| **주요 목적** | 특정 값을 반환하는 **상태** 제공 | 특정 행동이 발생했는지 **검증** | 실제 객체의 **호출을 관찰** |
| **핵심 역할** | 가짜 데이터 제공자 | 예상 행동 검증자 | 실제 객체 감시자 |
| **사용 시점** | 특정 응답이 필요할 때 | 객체 간 상호작용 검증 시 | 실제 객체 로직 일부를 관찰/대체할 때 |
| **제공 로직** | 하드코딩된 단순 값 | 검증 로직 | 실제 객체 로직 + 관찰/대체 로직 |
| **테스트 방식** | 상태 기반(State-based) | 행동 기반(Behavior-based) | 행동 기반(Behavior-based) |

-----

### 결론

Mock, Stub, Spy는 유닛 테스트의 효율성과 신뢰성을 높여주는 강력한 도구입니다. 이들은 테스트 대상 객체를 외부 의존성으로부터 **격리**하고, 예측 가능한 테스트 환경을 조성하여 테스트의 안정성을 보장합니다.

* **Stub**은 주로 테스트에 필요한 **데이터**를 제공하는 역할을 합니다.
* **Mock**은 테스트 대상의 **행동**이 올바른지를 검증하는 데 사용됩니다.
* **Spy**는 실제 객체의 동작을 관찰하거나 부분적으로만 제어하고 싶을 때 유용합니다.

효율적인 테스트 코드를 작성하기 위해서는 이 세 가지 개념을 명확히 이해하고, 각 상황에 맞는 도구를 적절하게 선택하여 적용해야 합니다. 이 지식을 바탕으로 더욱 견고하고 유지보수가 쉬운 코드를 작성할 수 있을 것입니다.
