### 서론: HTTP, 웹 통신의 근간

현대 웹 애플리케이션과 서비스를 개발하면서 HTTP(HyperText Transfer Protocol)는 개발자가 매일 마주하는 가장 기본적인 통신 규약입니다. 클라이언트와 서버가, 혹은 서버와 서버가 데이터를 주고받는 모든 과정의 중심에 HTTP가 있습니다. 하지만 단순히 'GET으로 요청하고 JSON으로 받는다'는 표면적인 이해를 넘어, HTTP가 어떻게 발전해왔고 각 버전이 어떤 문제를 해결했는지, 그리고 그 구조가 어떻게 이루어져 있는지를 아는 것은 중요합니다.

이 글에서는 HTTP/1.0부터 최신의 HTTP/3까지의 핵심적인 변화를 추적하고, HTTP 메시지의 기본 구조를 명확하게 정리합니다.

---

### 본론 1: HTTP의 정의와 역사적 변천

HTTP는 **HyperText Transfer Protocol**의 약자로, 초기에는 이름처럼 하이퍼텍스트(HTML) 문서를 교환하기 위해 만들어진 통신 규약입니다. 하지만 지금은 이미지, 비디오, JSON, XML 등 웹에서 사용되는 거의 모든 형태의 리소스를 전송하는 데 사용됩니다. 본질적으로는 서버와 클라이언트 간에 어떤 형식으로 통신할지에 대해 정해둔 규약입니다.

이 규약은 성능과 효율성을 개선하기 위해 지속적으로 발전해왔습니다.

#### HTTP/1.0: 기본의 확립

HTTP/1.0에서 헤더(Header), 상태 코드(Status), 그리고 콘텐츠 타입(Content-Type)과 같은 현대 HTTP의 핵심 개념이 추가되었습니다. 하지만 이 버전은 **치명적인 비효율성**을 가졌습니다. 하나의 요청(Request)마다 TCP/IP 연결을 새로 맺고 응답(Response)을 받으면 연결을 끊어야 했습니다. 이는 서버에 큰 부담을 주었으며, `keep-alive` 옵션을 헤더에 명시해야만 연결을 유지할 수 있었습니다.

#### HTTP/1.1: 파이프라이닝과 HOL Blocking

HTTP/1.1은 현재까지도 널리 사용되는 버전입니다. `keep-alive`가 기본 설정(Persistent Connection)이 되어 매번 연결을 새로 맺는 비효율이 사라졌습니다.

또한 **파이프라이닝(Pipelining)** 기술이 도입되었습니다. 이는 하나의 연결에서 여러 개의 요청을 순차적으로 보내고, 순서에 맞춰 응답을 받는 방식입니다. 하지만 이 방식은 첫 번째 요청이 완료될 때까지 두 번째, 세 번째 요청의 응답이 지연되는 **HOL Blocking (Head-of-Line Blocking)** 문제를 야기했습니다.

#### HTTP/2: 멀티플렉싱으로의 도약

HTTP/1.x의 가장 큰 문제인 HOL Blocking을 해결하기 위해 HTTP/2가 등장했습니다.

* **멀티플렉싱(Multiplexing)**: HTTP/2는 통신의 가장 작은 단위를 **프레임(Frame)**으로 정의했습니다. 이 프레임들이 모여 메시지(Message)가 되고, 메시지들이 모여 하나의 스트림(Stream)을 이룹니다. 이 구조 덕분에, 하나의 TCP 연결을 통해 여러 개의 스트림(요청과 응답)이 동시에, 순서에 상관없이 전송될 수 있습니다. 서버와 클라이언트는 각 프레임의 고유 ID를 보고 순서를 재조립합니다.
* **헤더 압축(Header Data Compression)**: 중복되는 헤더 정보를 HPACK이라는 압축 방식을 사용해 효율적으로 전송합니다.



#### HTTP/3: QUIC을 통한 혁신

HTTP/2는 TCP 기반이기에, TCP 레벨에서 발생하는 HOL Blocking은 여전히 존재했습니다. (패킷 하나가 유실되면 전체 TCP 연결이 지연됨).

HTTP/3는 이 문제를 해결하기 위해 TCP 대신 UDP 기반의 **QUIC(Quick UDP Internet Connection)** 프로토콜을 사용합니다.

* **핸드셰이크 간소화**: 기존의 TLS(암호화) 핸드셰이크와 TCP(연결) 핸드셰이크를 QUIC이라는 하나의 프로토콜로 통합하여 연결 속도를 획기적으로 줄였습니다.
* **Connection ID**: IP와 Port 대신 랜덤한 값인 **Connection ID**를 사용하여 연결을 식별합니다. 이 덕분에 사용자의 네트워크 환경이 변경되어도(예: Wi-Fi에서 LTE로 전환) 연결이 끊기지 않고 유지됩니다.



---

### 본론 2: HTTP 메시지의 구성 요소

HTTP 메시지는 클라이언트의 요청(Request)과 서버의 응답(Response) 모두 크게 세 부분으로 구성됩니다.



1.  **Start Line (시작 줄)**
    * **Request**: `METHOD Request-Target HTTP-Version` (예: `GET /index.html HTTP/1.1`)
    * **Response**: `HTTP-Version Status-Code Status-Text` (예: `HTTP/1.1 200 OK`)

2.  **Header (헤더)**
    * 요청과 응답에 대한 부가적인 정보를 담습니다.
    * **General Header**: 요청/응답 모두에 적용되는 일반 정보 (예: `Date`)
    * **Request Header**: 클라이언트에 대한 정보 (예: `Host`, `User-Agent`, `Accept`)
    * **Response Header**: 서버에 대한 정보 (예: `Server`, `Allow`)
    * **Entity Header (Representation Header)**: 전송되는 본문(Body)에 대한 정보 (예: `Content-Type`, `Content-Length`). (HTTP/1.1 명세에서 Entity Header는 Deprecated 되고 Representation Header로 통합되었습니다.)

3.  **Body (본문)**
    * 실제로 전송되는 데이터(Payload)입니다. (예: HTML 문서, JSON 데이터)
    * GET, HEAD, OPTIONS 같은 메서드는 대부분 Body가 없습니다.

---

### 본론 3: 주요 HTTP 메서드와 활용

HTTP 메서드는 서버에 요청하는 동작의 종류를 명시합니다.

| 메서드 | 설명 | 주요 용도 |
| :--- | :--- | :--- |
| **GET** | 리소스를 조회(Read)합니다. | 데이터 조회 |
| **HEAD** | GET과 동일하지만, 응답 Body를 제외한 헤더만 요청합니다. | 리소스 존재 여부, 서버 정보, 최종 수정일자 확인 |
| **POST** | 새로운 리소스를 생성(Create)하거나 데이터를 처리합니다. | 회원 가입, 게시글 작성, 데이터 전송 |
| **PUT** | 리소스 전체를 수정(Update)하거나 대체합니다. | 정보 수정 (전체 덮어쓰기) |
| **PATCH** | 리소스의 일부를 수정(Update)합니다. | 정보 수정 (부분 변경) |
| **DELETE** | 리소스를 삭제(Delete)합니다. | 데이터 삭제 |
| **OPTIONS** | 서버가 지원하는 메서드 목록을 요청합니다. | CORS Preflight 요청 시, 서버의 허용 정책 확인 |
| **CONNECT** | 프록시 서버를 통해 TCP 터널 생성을 요청합니다. | HTTPS 연결 시 사용 |

---

### 결론: HTTP의 이해는 견고한 백엔드의 시작

HTTP는 단순한 '프로토콜'을 넘어, 웹 생태계가 수십 년간 발전해 온 역사 그 자체입니다. 개발자로서 우리는 HTTP/1.1의 HOL Blocking 문제를 인지하고, HTTP/2의 멀티플렉싱, HTTP/3의 QUIC이 왜 등장했는지 이해해야 합니다.

이러한 깊이 있는 이해는 성능 문제를 진단하고, 효율적인 API를 설계하며, 더 나은 사용자 경험을 제공하는 견고한 시스템을 구축하는 밑거름이 될 것입니다.