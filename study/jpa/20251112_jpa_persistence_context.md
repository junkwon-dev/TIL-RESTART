## JPA 엔티티 라이프사이클: 4가지 상태 완벽 가이드

### 서론

JPA(Java Persistence API)를 효과적으로 사용하기 위해서는 \*\*영속성 컨텍스트(Persistence Context)\*\*와 그 안에서 관리되는 \*\*엔티티 생명주기(Entity Lifecycle)\*\*에 대한 명확한 이해가 필수입니다. 영속성 컨텍스트는 엔티티를 관리하는 환경을 의미하며, 엔티티는 이 환경 안에서 생성, 조회, 수정, 삭제되는 고유한 생명주기를 갖습니다.

JPA의 모든 핵심 기능(1차 캐시, 변경 감지 등)은 이 생명주기와 밀접하게 연관되어 있습니다. 이 글에서는 JPA 엔티OS티가 가지는 4가지 생명주기 상태와 각 상태 간의 전이 과정을 상세히 정리합니다.

-----

## 엔티티의 4가지 생명주기

JPA 엔티티는 영속성 컨텍스트와의 관계에 따라 4가지 상태로 구분됩니다.

1.  **비영속 (New / Transient)**: 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태.
2.  **영속 (Managed / Persistent)**: 영속성 컨텍스트에 의해 관리되는 상태.
3.  **준영속 (Detached)**: 영속성 컨텍스트에 저장되었다가 분리된 상태.
4.  **삭제 (Removed)**: 데이터베이스에서 삭제가 예정된 상태.

각 상태를 영속성 컨텍스트의 관리 여부로 요약하면 다음과 같습니다.

| 상태 | 영문명 | 영속성 컨텍스트 관리 여부 |
| :--- | :--- | :--- |
| **비영속** | New / Transient | ❌ (관리하지 않음) |
| **영속** | Managed / Persistent | ✅ (관리 중) |
| **준영속** | Detached | ❌ (관리했었으나, 이탈) |
| **삭제** | Removed | ✅ (삭제 예정으로 관리 중) |

-----

## 1\. 비영속 (New / Transient)

비영속 상태는 엔티티 객체를 생성했지만, 아직 영속성 컨텍스트에 저장하지 않은 순수한 객체 상태입니다. 이 상태의 객체는 영속성 컨텍스트나 데이터베이스와는 어떠한 관계도 없습니다.

```java
@Entity
@Table(name = "MEMBER")
public class Member {
    @Id
    @Column(name = "ID")
    private String id;
    private String name;
    private int age;
    // ... Getters and Setters ...
}

// 비영속(New) 상태의 엔티티
Member member = new Member("1", "김대용", 23);
```

## 2\. 영속 (Managed / Persistent)

영속 상태는 엔티티가 영속성 컨텍스트에 의해 관리되는 상태입니다. \*\*`em.persist()`\*\*를 통해 새로운 엔티티를 저장하거나, \*\*`em.find()`\*\*를 통해 데이터베이스에서 엔티티를 조회하면 해당 엔티티는 영속 상태가 됩니다.

```java
EntityManager em = entityManagerFactory.createEntityManager();
// ... 트랜잭션 시작 ...

// member 객체가 영속 상태가 됩니다. (1차 캐시에 저장)
em.persist(member);
```

영속 상태의 엔티티는 JPA가 제공하는 핵심 기능들의 혜택을 받습니다.

### 1차 캐시 (1st-Level Cache)

영속 상태가 된 엔티티는 영속성 컨텍스트 내부의 **1차 캐시**에 저장됩니다. 1차 캐시는 \*\*`@Id`\*\*를 키로, 엔티티 인스턴스를 값으로 가지는 Map과 유사하게 동작합니다.

* **`em.find()`** 호출 시, 먼저 1차 캐시를 확인합니다.
* 캐시에 엔티티가 존재하면 DB 조회를 생략하고 캐시된 인스턴스를 반환합니다.
* 이를 통해 **동일성을 보장**하며, 성능상 이점을 얻습니다.

<!-- end list -->

```java
Member memberA = em.find(Member.class, "1"); // DB에서 조회 (SELECT)
Member memberB = em.find(Member.class, "1"); // 1차 캐시에서 조회 (SELECT 없음)

// memberA와 memberB는 동일한 인스턴스입니다.
// (memberA == memberB) == true
```

### 변경 감지 (Dirty Checking)

영속성 컨텍스트는 엔티티를 1차 캐시에 저장할 때 최초 상태의 **스냅샷**을 함께 보관합니다.

1.  트랜잭션 커밋(**`tx.commit()`**) 또는 플러시(**`em.flush()`**) 시점에,
2.  1차 캐시 내 엔티티의 현재 상태와 저장된 스냅샷을 비교합니다.
3.  변경 사항이 감지되면, **UPDATE SQL**을 생성하여 \*\*쓰기 지연 SQL 저장소(Write-Behind)\*\*에 등록합니다.
4.  이후 트랜잭션이 커밋되면서 쓰기 지연 저장소의 SQL들이 데이터베이스에 일괄 반영(flush)됩니다.

<!-- end list -->

```java
// ... 트랜잭션 시작 ...
Member member = em.find(Member.class, "1"); // 영속 상태

// 별도의 update() 메서드 호출 없이 값만 변경합니다.
member.setName("김머용");

// 트랜잭션 커밋 시, 변경 감지가 동작하여 UPDATE SQL이 실행됩니다.
tx.commit();
```

## 3\. 준영속 (Detached)

준영속 상태는 영속성 컨텍스트가 관리하던 엔티티가 관리 대상에서 제외된(이탈한) 상태입니다. 1차 캐시, 변경 감지, 쓰기 지연 등 영속성 컨텍스트가 제공하는 어떤 기능도 동작하지 않습니다.

### 준영속 상태로 만드는 방법

* **`em.detach(entity)`**: 특정 엔티티만 준영속 상태로 전환합니다. 1차 캐시에서 해당 엔티티가 제거됩니다.
* **`em.clear()`**: 영속성 컨텍스트의 1차 캐시를 모두 비워, 모든 영속 엔티티를 준영속 상태로 만듭니다.
* **`em.close()`**: 영속성 컨텍스트를 종료합니다. 관리되던 모든 엔티티가 준영속 상태가 됩니다.
* **`tx.commit()` / `tx.rollback()`**: 트랜잭션이 종료되면 해당 영속성 컨텍스트가 관리하던 엔티티들이 준영속 상태가 됩니다.

### 준영속 엔티티의 재-영속화: merge()

준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 **`em.merge()`** 메서드를 사용해야 합니다.

\*\*`merge()`\*\*는 전달받은 준영속 엔티티의 식별자(ID)를 이용해 1차 캐시나 데이터베이스에서 영속 엔티티를 조회합니다.

1.  조회한 **영속 엔티티**에 준영속 엔티티의 값을 덮어씌웁니다.
2.  그 **영속 엔티티**를 반환합니다.

> **주의**: \*\*`merge()`\*\*는 준영속 엔티티 자체를 영속 상태로 되돌리는 것이 아니라, 새로운 영속 엔티티를 반환합니다. 따라서 **`merge()`** 이후에는 반드시 반환된 객체를 사용해야 합니다.

```java
// member는 현재 준영속 상태라고 가정합니다.
Member mergedMember = em.merge(member);

// merge() 후에는 반환된 객체(mergedMember)를 사용해야 합니다.
// 'member' 객체는 여전히 준영속 상태입니다.
```

## 4\. 삭제 (Removed)

삭제 상태는 엔티티를 데이터베이스에서 삭제하기 위해 \*\*`em.remove()`\*\*를 호출한 상태입니다.

* 이 상태의 엔티티는 삭제가 예정되었지만, 트랜잭션 커밋 전까지는 **여전히 영속성 컨텍스트에 의해 관리**됩니다.
* \*\*`em.remove()`\*\*가 호출되면 **DELETE SQL**이 쓰기 지연 SQL 저장소에 등록됩니다.
* 이후 트랜잭션이 커밋되거나 플러시될 때 **DELETE SQL**이 실행되고, 1차 캐시에서도 제거됩니다.

<!-- end list -->

```java
// ... 트랜잭션 시작 ...
Member member = em.find(Member.class, "1"); // 영속 상태

// 삭제 상태(Removed)로 변경됩니다.
em.remove(member);

// 트랜잭션 커밋 시 DELETE SQL이 실행됩니다.
tx.commit();
```

-----

## 결론

JPA 엔티티의 생명주기는 **영속성 컨텍스트**를 중심으로 **비영속, 영속, 준영속, 삭제**의 4가지 상태를 오가며 관리됩니다. **1차 캐시**, **쓰기 지연**, **변경 감지**와 같은 JPA의 강력한 기능들은 모두 엔티티가 **영속(Managed)** 상태일 때만 동작합니다.

이 생명주기를 정확히 이해하면, 불필요한 DB 조회를 줄이고(1차 캐시 활용), 성능을 최적화(쓰기 지연)하며, **`DetachedEntityException`** 같은 예외 상황에 효과적으로 대처할 수 있습니다. 엔티티의 현재 상태를 항상 인지하고 JPA를 활용하는 것이 중요합니다.