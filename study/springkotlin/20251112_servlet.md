## 서블릿, 서블릿 컨테이너, DispatcherServlet: 스프링 웹 요청 흐름의 이해

### 서론

스프링 MVC(Spring MVC) 프레임워크로 웹 애플리케이션을 개발할 때, 브라우저의 HTTP 요청이 어떻게 `@Controller`의 특정 메서드까지 도달하는지 그 과정은 종종 추상화되어 있습니다. 이 복잡한 여정의 중심에는 **서블릿(Servlet)**, **서블릿 컨테이너(Servlet Container)**, 그리고 스프링 MVC의 핵심인 **DispatcherServlet**이 존재합니다.

이 글에서는 이 핵심 구성 요소들이 어떻게 상호작용하여 웹 요청을 처리하는지, 그리고 이 흐름 속에서 **필터(Filter)**와 **인터셉터(Interceptor)**가 어떤 공통 관심사(Cross-Cutting Concerns)를 처리하는지 명확히 정리합니다.

---

## 1. 서블릿 (Servlet): 기본 작업자

**서블릿(Servlet)**은 자바 언어로 작성된 웹 컴포넌트입니다. 이는 클라이언트의 HTTP 요청을 받아 동적인 웹 콘텐츠를 생성하고, 그 결과를 응답으로 반환하는 역할을 수행합니다.

* **역할**: `service()`, `doGet()`, `doPost()`와 같은 메서드 내부에 요청/응답 처리 로직을 직접 구현합니다.
* **특징**: 초기 서블릿 모델은 자바 코드 내에서 직접 HTML을 생성하여 응답해야 했습니다. 이 방식은 비즈니스 로직과 뷰(View) 로직이 혼재되어 코드가 복잡해지는 단점이 있었습니다.
* **비유**: 서블릿은 "요청이 들어왔을 때 1차적으로 직접 응대하는 기본 직원"에 비유할 수 있습니다.

## 2. 서블릿 컨테이너 (Servlet Container): 관리 환경

**서블릿 컨테이너(Servlet Container)**는 서블릿의 생명주기를 관리하고, 서블릿이 동작할 수 있는 실행 환경을 제공하는 구성 요소입니다. 개발자가 서블릿을 직접 실행하는 것이 아니라, 컨테이너에 등록(배포)하면 컨테이너가 이를 관리합니다.

* **대표 예시**: **Tomcat**, Jetty, Undertow 등이 있습니다. (스프링 부트는 기본적으로 Tomcat을 내장하고 있습니다.)
* **핵심 역할**:
    * **생명주기 관리**: 서블릿 객체의 생성, 초기화(`init`), 요청 전달(`service`), 그리고 소멸(`destroy`)까지의 전 과정을 관리합니다.
    * **스레드 관리**: 클라이언트의 요청이 발생할 때마다 스레드 풀(Thread Pool)을 사용하여 요청을 처리할 스레드를 생성하고 할당합니다.
    * **네트워킹 및 기타 지원**: 소켓 통신, 보안, 세션 관리 등 웹 애플리케이션에 필요한 저수준의 복잡한 작업들을 대신 처리해줍니다.



## 3. DispatcherServlet: 스프링의 중앙 관제소

스프링 MVC는 서블릿을 직접 다루는 대신, **DispatcherServlet**이라는 강력한 구성 요소를 제공합니다.

* **정의**: `DispatcherServlet`은 스프링 MVC가 제공하는 핵심 서블릿이며, **프론트 컨트롤러(Front Controller)** 디자인 패턴의 구현체입니다.
* **동작 방식**:
    1.  스프링 부트 애플리케이션이 실행되면, 내장 **Tomcat(서블릿 컨테이너)**이 기동합니다.
    2.  스프링은 이 Tomcat에 `DispatcherServlet`을 유일한 메인 서블릿으로 등록합니다.
    3.  서블릿 컨테이너(Tomcat)는 수신한 모든 HTTP 요청을 `DispatcherServlet`으로 전달합니다.
    4.  `DispatcherServlet`은 요청을 분석하여, 이 요청을 처리할 실제 **컨트롤러(Handler)**(즉, 개발자가 작성한 `@Controller`의 메서드)로 작업을 위임(Dispatch)합니다.



이 구조 덕분에 개발자는 `doGet`이나 `doPost` 같은 서블릿의 저수준 API를 직접 다루지 않고, `@RequestMapping`, `@GetMapping` 등을 통해 비즈니스 로직에만 집중할 수 있습니다.

## 4. 필터 (Filter)와 인터셉터 (Interceptor)

웹 요청을 처리하다 보면 로깅, 인증, 인코딩 변환 등 여러 컨트롤러에서 반복적으로 수행해야 하는 공통 작업(공통 관심사)이 발생합니다. **필터(Filter)**와 **인터셉터(Interceptor)**는 이러한 작업을 처리하는 데 사용됩니다.



### 필터 (Servlet Filter)
* **소속**: 서블릿 표준(J2EE/Jakarta EE) 사양입니다.
* **실행 위치**: 서블릿 컨테이너 레벨에서 동작합니다. 즉, `DispatcherServlet`에 요청이 도달하기 **전**에, 그리고 `DispatcherServlet`이 응답을 보낸 **후**에 실행됩니다.
* **주요 용도**: 요청/응답의 헤더나 내용을 조작하는 원시적인 작업에 적합합니다. (예: 문자 인코딩 변환, 보안 인증, CORS 설정)

### 인터셉터 (Spring Interceptor)
* **소속**: 스프링 MVC 프레임워크가 제공하는 기능입니다.
* **실행 위치**: `DispatcherServlet` **내부**에서 동작합니다. `DispatcherServlet`이 컨트롤러를 호출하기 **전**과 **후**에 실행됩니다.
* **주요 용도**: 스프링의 IoC 컨텍스트에 접근할 수 있습니다. 컨트롤러로 넘어가는 **`ModelAndView`** 객체나 사용자 세션 정보 등을 확인하고 조작하는 데 용이합니다. (예: 로그인 세션 체크, 권한 검증)

### 필터와 인터셉터 비교

| 구분 | **필터 (Filter)** | **인터셉터 (Interceptor)** |
| :--- | :--- | :--- |
| **소속** | 서블릿 표준 (J2EE/Jakarta EE) | 스프링 MVC 프레임워크 |
| **실행 위치** | 서블릿 컨테이너 (DispatcherServlet 앞/뒤) | 스프링 컨텍스트 (DispatcherServlet 내부) |
| **관리 주체** | 서블릿 컨테이너 (Tomcat 등) | 스프링 IoC 컨테이너 |
| **주요 용도** | 인코딩 변환, 보안(Security), CORS | 사용자 인증, 세션 체크, 로깅 |
| **접근 가능 영역** | 원시 `HttpServletRequest`/`Response` | `ModelAndView`, `@Controller` 정보 |

---

## 결론

스프링 MVC의 웹 요청 처리 흐름은 명확한 역할 분담을 기반으로 합니다.

1.  **서블릿 컨테이너(Tomcat)**가 하드웨어(네트워크)와 통신하며 요청을 수신합니다.
2.  컨테이너는 모든 요청을 스프링의 중앙 관제소인 **`DispatcherServlet`**에게 위임합니다.
3.  `DispatcherServlet`은 요청을 분석하여 가장 적절한 **컨트롤러**에게 실제 비즈니스 로직 처리를 위임합니다.
4.  이 모든 과정의 앞뒤에서 **필터**와 **인터셉터**가 공통 관심사를 효율적으로 처리합니다.

이러한 계층적 아키텍처는 개발자가 서블릿의 복잡한 생명주기나 스레드 관리에 신경 쓰지 않고, 오직 비즈니스 로직 구현에만 집중할 수 있도록 돕는 스프링 프레임워크의 핵심 철학을 보여줍니다.