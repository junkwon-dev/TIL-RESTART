## JVM 내부 구조: 자바 가상 머신 완벽 해부

### 서론

자바(Java) 언어뿐만 아니라 코틀린(Kotlin), 스칼라(Scala) 등 많은 현대 언어가 자바 가상 머신(JVM) 위에서 동작합니다. JVM의 내부 구조와 동작 방식을 정확히 이해하는 것은, 코드 최적화, 메모리 관리, 그리고 복잡한 문제 해결(Troubleshooting)의 기반이 됩니다. 많은 개발자가 JVM을 면접 질문의 단골 주제로 꼽는 이유이기도 합니다.

이 글에서는 자바 애플리케이션이 실행되는 과정, 특히 컴파일된 `.class` 파일이 **JVM(자바 가상 머신)**을 거쳐 어떻게 실행되는지 그 내부 구조를 상세히 정리합니다.



[Image of Java program execution flow]


---

## JVM 동작 방식 및 기본 구조

자바 프로그램을 실행하면, JVM은 운영체제(OS)로부터 실행에 필요한 메모리를 할당받습니다. 전체적인 실행 흐름은 다음과 같습니다.

1.  자바 컴파일러(`javac`)가 자바 소스코드(`.java`)를 자바 바이트 코드(`.class`)로 컴파일합니다.
2.  **클래스 로더(Class Loader)**가 이 `.class` 파일들을 동적으로 로딩 및 링크하여 **런타임 데이터 영역(Runtime Data Area)**에 배치합니다.
3.  **실행 엔진(Execution Engine)**이 런타임 데이터 영역에 있는 바이트 코드를 해석하고 실행합니다.
4.  이 과정에서 가비지 컬렉터(GC)가 메모리를 관리하고 스레드 동기화가 이루어집니다.

### JVM의 3대 핵심 구성 요소

JVM은 크게 세 가지 핵심 구성 요소로 나뉩니다.

* 클래스 로더 (Class Loader)
* 런타임 데이터 영역 (Runtime Data Area)
* 실행 엔진 (Execution Engine)



이 세 가지 구성 요소를 중심으로 JVM의 내부를 자세히 살펴보겠습니다.

---

## 1. 클래스 로더 (Class Loader)

클래스 로더는 JVM 내로 `.class` 파일을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈입니다. 애플리케이션에서 필요할 때 클래스를 동적으로 메모리에 적재합니다.

클래스 로딩은 다음 3단계로 구성됩니다.



1.  **Loading (로드)**: `.class` 파일을 찾아 JVM의 메모리(메서드 영역)에 로드합니다.
2.  **Linking (링크)**: 로드된 클래스 파일을 사용하기 위해 검증하고 준비하는 과정입니다.
    * **Verifying (검증)**: `.class` 파일이 JVM 명세에 맞게 구성되었는지 검사합니다.
    * **Preparing (준비)**: 클래스가 필요로 하는 메모리(정적 변수 등)를 할당합니다.
    * **Resolving (분석)**: 심볼릭 레퍼런스(이름 기반 참조)를 다이렉트 레퍼런스(메모리 주소 기반 참조)로 변경합니다.
3.  **Initialization (초기화)**: 클래스 변수(static 필드)를 적절한 값으로 초기화합니다.

---

## 2. 런타임 데이터 영역 (Runtime Data Area)

런타임 데이터 영역은 JVM의 메모리 영역으로, 자바 애플리케이션 실행 시 사용되는 모든 데이터를 적재하는 공간입니다. 이 영역은 **스레드 공유 영역**과 **스레드별 개별 영역**으로 나뉩니다.



### 스레드 공유 영역 (All Threads Share)

모든 스레드가 공유하는 데이터 영역입니다.

#### ① 메서드 영역 (Method Area)
JVM이 시작될 때 생성되며, 클래스 파일의 바이트 코드를 로드할 때 초기화되는 대상을 저장합니다. **'Static Area'** 또는 **'Class Area'**라고도 불립니다.

* **저장 정보**: 필드 정보(이름, 타입), 메서드 정보(이름, 리턴 타입), 타입 정보(클래스/인터페이스 여부), **런타임 상수 풀(Runtime Constant Pool)** 등 클래스 구조 정보와 정적(static) 변수가 저장됩니다.

#### ② 힙 영역 (Heap Area)
프로그램 실행 중 `new` 연산자를 통해 생성되는 **모든 객체 인스턴스**와 **배열**이 저장되는 공간입니다. 힙 영역은 **가비지 컬렉터(GC)**의 주된 관리 대상입니다.

효율적인 GC를 위해 힙 영역은 물리적으로 다음과 같이 나뉩니다.

| 영역 구분 | 세부 영역 | 설명 |
| :--- | :--- | :--- |
| **Young Generation** | Eden | `new`로 생성된 객체가 처음 위치하는 공간입니다. |
| | Survivor 0 / 1 | Eden 영역에서 GC 후 살아남은 객체가 이동하는 공간입니다. |
| **Old Generation** | - | Young Generation에서 특정 횟수 이상 살아남은, 즉 생명 주기가 긴 객체가 이동하는 공간입니다. |

### 스레드별 개별 영역 (Per-Thread)

각 스레드가 생성될 때마다 개별적으로 생성되는 영역입니다.

#### ③ 스택 영역 (Stack Area)
메서드 호출 정보를 저장하는 공간입니다. 메서드가 호출될 때마다 **스택 프레임(Stack Frame)**이 생성되어 스택에 쌓이고(push), 메서드 실행이 완료되면 해당 프레임이 스택에서 제거(pop)됩니다.

* **스택 프레임**: 메서드의 매개변수, 지역 변수, 리턴 값 등을 저장합니다.
* **저장 방식**:
    * **기본 타입(Primitive type)**: `int`, `long` 등은 **값 자체**를 스택에 저장합니다.
    * **참조 타입(Reference type)**: 객체의 **힙(Heap) 영역 주소**를 스택에 저장합니다.

#### ④ PC 레지스터 (PC Register)
'Program Counter'의 약자로, 현재 스레드가 실행 중인 JVM 명령어의 주소를 저장합니다. 스레드마다 하나씩 존재하며, 이를 통해 스레드 간 전환(Context Switching) 시 돌아와야 할 실행 위치를 기억할 수 있습니다.

#### ⑤ 네이티브 메서드 스택 (Native Method Stack)
자바 외의 언어(C, C++ 등)로 작성된 **네이티브 코드**를 실행하기 위한 별도의 스택 공간입니다.

---

## 3. 실행 엔진 (Execution Engine)

실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다.

### 인터프리터 (Interpreter) vs. JIT 컴파일러 (JIT Compiler)

JVM은 바이트 코드를 실행하기 위해 두 가지 방식을 혼합하여 사용합니다.

* **인터프리터 (Interpreter)**: 바이트 코드 명령어를 **한 줄씩** 읽어서 해석하고 바로 실행합니다. 동일한 메서드가 여러 번 호출되어도 매번 해석해야 하므로 속도가 느릴 수 있습니다.
* **JIT 컴파일러 (Just-In-Time Compiler)**: 인터프리터의 단점을 보완하기 위해 도입되었습니다. 반복적으로 실행되는 코드(Hot Spot)를 감지하여, 해당 바이트 코드 전체를 **네이티브 코드(기계어)**로 컴파일합니다. 이 네이티브 코드는 캐싱되어 이후에는 컴파일 없이 바로 실행되므로 속도가 매우 빠릅니다.

| 구분 | 인터프리터 (Interpreter) | JIT 컴파일러 (JIT Compiler) |
| :--- | :--- | :--- |
| **실행 방식** | 바이트 코드를 한 줄씩 해석 및 실행 | 바이트 코드 전체를 네이티브 코드로 컴파일 |
| **속도** | 초기 실행은 빠르나 반복 시 느림 | 초기 컴파일 비용이 있으나 반복 시 빠름 |
| **주요 역할** | 프로그램의 초기 구동 담당 | 반복되는 코드의 성능 최적화 담당 |

### 가비지 컬렉터 (Garbage Collector, GC)
실행 엔진에 포함되어 동작하는 GC는 힙 영역에서 더 이상 참조되지 않는 객체(쓰레기)를 찾아내어 **자동으로 메모리를 회수**합니다. 이를 통해 개발자가 직접 메모리를 해제해야 하는 부담을 줄여줍니다.

---

## JNI (Java Native Interface)

JNI는 자바 가상 머신이 C, C++ 등 다른 언어로 작성된 네이티브 메서드 라이브러리와 상호작용할 수 있도록 제공하는 인터페이스입니다. 이를 통해 JVM은 네이티브 메서드 스택을 활용하여 자바가 아닌 코드의 기능을 호출할 수 있습니다.

---

## 결론

JVM은 **클래스 로더**, **런타임 데이터 영역**, **실행 엔진**이라는 세 가지 핵심 구성 요소가 유기적으로 상호작용하며 동작합니다.

* **클래스 로더**가 `.class` 파일을 **런타임 데이터 영역**에 적재합니다.
* **실행 엔진**이 **런타임 데이터 영역**의 바이트 코드를 가져와 실행합니다.
* 이 과정에서 **힙(Heap)** 메모리는 **GC**에 의해 관리되고, **스택(Stack)**은 메서드 호출에 따라 동적으로 사용됩니다.

JVM의 내부 구조를 이해하는 것은 단순히 지식을 넘어, **메모리 릭(Memory Leak) 추적**, **GC 튜닝**을 통한 성능 최적화, 그리고 **StackOverflowError**와 같은 에러의 원인을 파악하는 데 필수적인 역량입니다. 자바, 코틀린, 스칼라 개발자라면 이러한 JVM의 동작 원리를 숙지하여 더 견고하고 효율적인 애플리케이션을 구축해야 합니다.
