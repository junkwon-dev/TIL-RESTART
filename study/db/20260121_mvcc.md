## 개요

데이터베이스 관리 시스템에서 동시성은 성능과 직결되는 핵심 요소입니다. 여러 사용자가 동시에 데이터를 조회하고 수정하는 환경에서 데이터의 일관성을 유지하는 것은 매우 까다로운 작업입니다.

전통적인 데이터베이스는 데이터 정합성을 위해 공유 락(Shared Lock)과 배타 락(Exclusive Lock)을 사용했습니다. 하지만 읽기 작업이 쓰기 작업을 기다리거나, 쓰기 작업이 읽기 작업을 방해하는 구조는 높은 트래픽을 처리하기에 한계가 있었습니다. 이러한 문제를 해결하고 잠금 없는 읽기(Lock-free Read)를 구현하기 위해 등장한 기술이 바로 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)입니다.

이 글에서는 MVCC의 핵심 원리와 MySQL InnoDB 엔진이 Undo 로그를 통해 이를 어떻게 구현하는지, 그리고 남아있는 동시성 이슈를 해결하기 위한 전략을 분석합니다.

---

## MVCC의 개념과 등장 배경

MVCC는 하나의 레코드에 대해 여러 개의 버전을 관리하는 기술입니다. 데이터를 업데이트할 때 기존 데이터를 덮어쓰는 대신, 이전 버전의 데이터를 별도의 공간에 보관하여 읽기 작업과 쓰기 작업이 서로를 방해하지 않게 합니다.

### 격리 수준과 잠금의 한계

표준 SQL 격리 수준에 따른 데이터 부정합 현상은 다음과 같습니다. 이를 방지하기 위해 과거에는 엄격한 락킹 메커니즘을 사용했습니다.

| 격리 수준 (Isolation Level) | Dirty Read 발생 | Non-Repeatable Read 발생 | Phantom Read 발생 |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 방지 | 발생 | 발생 |
| REPEATABLE READ | 방지 | 방지 | 발생 (InnoDB는 방지) |
| SERIALIZABLE | 방지 | 방지 | 방지 |

과거의 방식인 Serializability 구현은 읽기 작업 시에도 읽기 락(Read Lock)을 획득해야 했으므로 전체적인 처리량(Throughput)이 급격히 저하되었습니다. MVCC는 이러한 성능 저하 없이 일관된 읽기를 제공하는 것을 목표로 합니다.

---

## InnoDB의 MVCC 구현 원리: Undo 로그

MySQL의 InnoDB 스토리지 엔진은 MVCC를 구현하기 위해 Undo 로그(Undo Log)를 활용합니다. 핵심은 데이터를 변경할 때 변경 전의 데이터를 Undo 영역에 복사해 두는 것입니다.

### 1. 데이터 변경 프로세스

특정 행의 데이터를 업데이트하면 다음과 같은 과정을 거칩니다.

1. 메모리(Buffer Pool) 내의 해당 레코드 값을 새로운 값으로 업데이트합니다.
2. 변경 전의 데이터는 Undo 로그 영역으로 복사됩니다.
3. 데이터 페이지에는 해당 변경을 수행한 트랜잭션의 ID(TRX_ID)를 기록합니다.

### 2. 일관된 읽기 (Consistent Read)

트랜잭션이 데이터를 조회할 때, 자신의 트랜잭션 ID와 레코드에 기록된 ID를 비교합니다. 만약 읽고자 하는 데이터가 다른 트랜잭션에 의해 수정 중이거나 아직 커밋되지 않았다면, InnoDB는 Undo 로그를 역추적하여 현재 트랜잭션이 볼 수 있는 시점의 데이터를 재구성합니다.

```sql
-- Transaction A (ID: 10)
START TRANSACTION;
UPDATE users SET name = 'MYSQL_USER' WHERE id = 1; -- 아직 커밋 안 함

-- Transaction B (ID: 11)
-- MVCC 덕분에 Transaction A가 커밋되지 않았어도 
-- Undo 로그를 통해 이전 값인 'User1'을 즉시 읽을 수 있습니다.
SELECT name FROM users WHERE id = 1; 

```

이 방식을 통해 읽기 작업은 쓰기 작업에 대한 락이 해제될 때까지 기다릴 필요가 없으므로 동시성 처리 성능이 극대화됩니다.

---

## 동시 업데이트 문제와 잠금 전략

MVCC는 읽기와 쓰기 사이의 충돌은 해결해주지만, 두 개의 트랜잭션이 동시에 동일한 행을 업데이트하려는 쓰기-쓰기 충돌(Write-Write Conflict)까지는 완전히 막아주지 못합니다. 이를 위해 개발자는 비관적 락이나 낙관적 락을 선택적으로 사용해야 합니다.

### 비관적 락 vs 낙관적 락 비교

| 구분 | 비관적 락 (Pessimistic Lock) | 낙관적 락 (Optimistic Lock) |
| --- | --- | --- |
| 개념 | 충돌이 발생할 것이라 가정하고 우선 락을 겁니다. | 충돌이 드물 것이라 가정하고 버전 정보를 체크합니다. |
| 방식 | SELECT ... FOR UPDATE 등 데이터베이스 락 사용 | Application 레벨에서 version 컬럼 등을 활용 |
| 장점 | 데이터 무결성을 강력하게 보장합니다. | 별도의 락을 잡지 않아 성능상 이점이 있습니다. |
| 단점 | 데드락 발생 가능성이 있고 동시성이 떨어집니다. | 충돌 시 롤백 처리를 직접 구현해야 합니다. |

### 예시 코드: 낙관적 락 구현

```java
// JPA를 이용한 낙관적 락 예시
@Entity
public class Product {
    @Id @GeneratedValue
    private Long id;
    
    private String name;
    
    @Version // 변경 시마다 버전 체크
    private Long version;
}

```

---

## 결론

MVCC는 현대 데이터베이스에서 고성능 동시 처리를 구현하기 위한 필수적인 기술입니다. InnoDB는 Undo 로그를 통해 커밋된 시점의 데이터를 관리함으로써 읽기 작업의 일관성과 성능을 동시에 확보했습니다.

개발자는 단순히 데이터베이스의 기능을 믿는 것에 그치지 않고, 시스템의 특성에 맞춰 적절한 격리 수준을 설정하고 필요한 경우 비관적 락이나 낙관적 락을 도입하여 동시성 이슈를 제어해야 합니다. 특히 재고 관리나 결제 시스템처럼 정확성이 생명인 도메인에서는 MVCC의 동작 원리를 이해하고 설계하는 것이 무엇보다 중요합니다.

---

## Reference

* MySQL 8.0 Reference Manual: InnoDB Multi-Versioning
* High Performance MySQL (4th Edition)