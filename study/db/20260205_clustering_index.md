## 클러스터링 인덱스와 세컨더리 인덱스의 구조적 차이 및 성능 최적화

데이터베이스 성능 최적화의 핵심은 인덱스 설계에 있습니다. 특히 MySQL의 InnoDB 스토리지 엔진과 같은 환경에서는 데이터를 물리적으로 어떻게 저장하고 탐색하느냐에 따라 쿼리 성능이 극명하게 갈립니다.

많은 개발자가 인덱스를 단순히 빠른 조회를 위한 도구로만 이해하지만, 클러스터링 인덱스(Clustered Index)와 세컨더리 인덱스(Secondary Index)의 내부 저장 방식 차이를 모르면 예상치 못한 성능 저하를 겪을 수 있습니다. 이 글에서는 두 인덱스의 물리적 구조와 데이터 접근 방식, 그리고 성능을 극대화하는 커버링 인덱스(Covering Index) 개념을 분석합니다.

---

## 1. 클러스터링 인덱스 (Clustered Index)

클러스터링 인덱스는 테이블의 행 데이터를 인덱스 리프 페이지에 물리적으로 정렬하여 저장하는 방식입니다. 인덱스 자체가 곧 데이터 페이지이므로, 테이블당 단 하나만 존재할 수 있습니다.

* 저장 방식: 프라이머리 키(PK) 값을 기준으로 레코드가 정렬됩니다.
* 구조적 특징: 리프 노드에 실제 데이터 행(Row) 전체가 포함되어 있습니다.
* 선정 기준: 기본적으로 프라이머리 키가 클러스터링 인덱스가 됩니다. PK가 없다면 Unique Not Null 컬럼을, 그것도 없다면 내부적으로 6바이트의 RowID를 생성하여 사용합니다.

### 클러스터링 인덱스의 특징

데이터가 물리적으로 정렬되어 있기 때문에 특정 범위의 데이터를 조회하는 범위 스캔(Range Scan)에서 압도적인 성능을 발휘합니다. 하지만 정렬 상태를 유지해야 하므로 데이터의 삽입(INSERT)이나 PK 수정 시 페이지 분할(Page Split)이 발생하여 오버헤드가 클 수 있습니다.

---

## 2. 세컨더리 인덱스 (Secondary Index)

세컨더리 인덱스는 클러스터링 인덱스 이외에 개발자가 추가로 생성한 인덱스를 의미합니다. 흔히 넌클러스터링 인덱스라고도 불립니다.

* 저장 방식: 인덱스 컬럼의 값과 해당 레코드의 클러스터링 인덱스 키(PK)를 저장합니다.
* 구조적 특징: 리프 노드에 실제 데이터가 아닌, 데이터를 찾아가기 위한 주소(PK 값)가 들어 있습니다.

### 데이터 접근 프로세스

세컨더리 인덱스를 통해 데이터를 조회할 때는 두 번의 탐색 과정이 필요합니다.

1. 세컨더리 인덱스 페이지에서 검색하고자 하는 값의 PK를 획득합니다.
2. 획득한 PK를 사용하여 클러스터링 인덱스를 다시 탐색하여 실제 레코드를 읽습니다.

이 과정을 MySQl에서는 리드 아웃(Read-out) 또는 런타임 조인이라고 부르기도 하며, 성능 관점에서는 추가적인 I/O를 발생시키는 요소입니다.

---

## 3. 인덱스 유형별 비교 분석

| 구분 | 클러스터링 인덱스 | 세컨더리 인덱스 |
| --- | --- | --- |
| 개수 | 테이블당 1개 | 테이블당 여러 개 가능 |
| 리프 노드 저장 값 | 실제 데이터 레코드 전체 | 인덱스 컬럼 값 + PK 값 |
| 물리적 정렬 여부 | PK 순서로 물리적 정렬됨 | 인덱스 컬럼 순으로 정렬됨 |
| 조회 성능 | 매우 빠름 (직접 접근) | 중간 (PK를 통한 재조회 필요) |
| CUD 영향 | 물리적 재정렬로 인한 비용 높음 | 인덱스 페이지 업데이트 비용 발생 |

---

## 4. 커버링 인덱스 (Covering Index)를 통한 성능 개선

세컨더리 인덱스의 단점인 두 번 조회 문제를 해결하는 방법이 바로 커버링 인덱스입니다. 커버링 인덱스는 쿼리에서 필요로 하는 모든 컬럼을 인덱스가 이미 포함하고 있는 상태를 의미합니다.

### 활용 사례

다음과 같은 쿼리가 있다고 가정합니다.

```sql
-- 인덱스: INDEX idx_user_name (name)
SELECT name, age FROM users WHERE name = 'Gemini';

```

이 경우 `age` 컬럼 정보가 인덱스에 없으므로 PK를 통해 데이터 페이지에 접근해야 합니다. 하지만 인덱스를 `(name, age)` 복합 인덱스로 구성하면, 인덱스 리프 노드에 이미 두 값이 모두 존재하므로 실제 데이터 페이지를 읽지 않고 결과를 반환합니다.

```sql
-- 최적화된 복합 인덱스: INDEX idx_user_name_age (name, age)
-- 실행 계획(Explain) 확인 시 'Using index'가 표시됩니다.
SELECT name, age FROM users WHERE name = 'Gemini';

```

커버링 인덱스를 활용하면 디스크 I/O를 획기적으로 줄일 수 있으며, 대량의 데이터를 처리할 때 매우 유용합니다.

---

## 결론

클러스터링 인덱스는 데이터 저장의 물리적 기준이며, 세컨더리 인덱스는 효율적인 탐색을 위한 보조 수단입니다. 인덱스 설계 시 다음 사항을 고려하여 활용하시기 바랍니다.

* 프라이머리 키는 변경이 거의 없고 조회가 빈번한 컬럼으로 설정합니다.
* 자주 조회되는 컬럼 조합은 세컨더리 인덱스로 생성하되, 필요 시 커버링 인덱스 전략을 사용합니다.
* 과도한 세컨더리 인덱스 생성은 쓰기 성능을 저하시키므로 적절한 균형이 필요합니다.

인덱스의 구조적 원리를 이해하는 것은 쿼리 튜닝의 시작입니다. 실제 서비스의 쿼리 실행 계획(Execution Plan)을 분석하며 인덱스가 의도대로 동작하는지 주기적으로 점검하는 습관을 갖는 것이 좋습니다.